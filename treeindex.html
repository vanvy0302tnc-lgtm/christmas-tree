<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Late Merry Christmas My Hảo - Magical Tree</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Great Vibes', cursive; }
        #video { display: none; }
        #title {
            position: absolute; top: 8%; width: 100%; text-align: center;
            color: #ffd700; font-size: 4.5rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4);
            pointer-events: none; z-index: 10;
        }
        #instructions {
            position: absolute; bottom: 5%; width: 100%; text-align: center;
            color: #fff; font-family: sans-serif; font-size: 0.9rem; opacity: 0.7;
        }
        #loading { position: absolute; top: 50%; width: 100%; text-align: center; color: white; }
    </style>
</head>
<body>
    <div id="title">Late Merry Christmas My Hảo</div>
    <div id="instructions">Click vào màn hình để bật nhạc Giáng sinh cực hay! <br> Dùng 2 ngón tay trước camera để phóng to/thu nhỏ.</div>
    <div id="loading">Đang tải nhạc hay và cây thông phép thuật...</div>
    
    <video id="video" playsinline></video>
    
    <audio id="christmasMusic" loop>
        <source src="https://www.chosic.com/wp-content/uploads/2021/11/We-Wish-You-A-Merry-Christmas-Lo-Fi-Version.mp3" type="audio/mpeg">
    </audio>

    <script>
        let scene, camera, renderer, treeGroup, star, snowflakeGroup, music;
        const videoElement = document.getElementById('video');

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // 1. THÂN CÂY BẰNG HẠT SÁNG VÀNG
            const trunkParticleCount = 2000;
            const trunkGeo = new THREE.BufferGeometry();
            const trunkPos = new Float32Array(trunkParticleCount * 3);
            const trunkColors = new Float32Array(trunkParticleCount * 3);

            for (let i = 0; i < trunkParticleCount; i++) {
                const y = Math.random() * 3.5;
                const r = Math.random() * 0.6;
                const angle = Math.random() * Math.PI * 2;
                trunkPos[i * 3] = Math.cos(angle) * r;
                trunkPos[i * 3 + 1] = y - 7.5;
                trunkPos[i * 3 + 2] = Math.sin(angle) * r;
                trunkColors[i * 3] = 1; // R
                trunkColors[i * 3 + 1] = 0.7 + Math.random() * 0.3; // G
                trunkColors[i * 3 + 2] = 0.2; // B
            }
            trunkGeo.setAttribute('position', new THREE.BufferAttribute(trunkPos, 3));
            trunkGeo.setAttribute('color', new THREE.BufferAttribute(trunkColors, 3));
            const trunkMat = new THREE.PointsMaterial({ size: 0.07, vertexColors: true, transparent: true, opacity: 0.8 });
            treeGroup.add(new THREE.Points(trunkGeo, trunkMat));

            // 2. TÁN LÁ CÂY HẠT SÁNG ĐA SẮC
            const particleCount = 18000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const y = Math.random() * 12;
                const r = (12 - y) * 0.45;
                const angle = Math.random() * Math.PI * 2;
                pos[i * 3] = Math.cos(angle) * r * Math.pow(Math.random(), 0.6);
                pos[i * 3 + 1] = y - 5.5; 
                pos[i * 3 + 2] = Math.sin(angle) * r * Math.pow(Math.random(), 0.6);

                const randColor = Math.random();
                if (randColor > 0.9) { // Đỏ
                    colors[i * 3] = 1; colors[i * 3 + 1] = 0.1; colors[i * 3 + 2] = 0.1;
                } else if (randColor > 0.8) { // Vàng rực
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 0;
                } else { // Xanh Noel
                    colors[i * 3] = 0; colors[i * 3 + 1] = 0.9; colors[i * 3 + 2] = 0.2;
                }
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, opacity: 0.9 });
            treeGroup.add(new THREE.Points(geo, mat));

            // 3. NGÔI SAO TO LẤP LÁNH
            const starShape = new THREE.OctahedronGeometry(0.8, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xfff000 });
            star = new THREE.Mesh(starShape, starMat);
            star.position.y = 6.8;
            treeGroup.add(star);

            // 4. HIỆU ỨNG TUYẾT RƠI DÀY HƠN
            const snowflakeCount = 2000;
            const snowflakeGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(snowflakeCount * 3);
            for (let i = 0; i < snowflakeCount; i++) {
                snowPos[i * 3] = Math.random() * 60 - 30;
                snowPos[i * 3 + 1] = Math.random() * 60 - 30;
                snowPos[i * 3 + 2] = Math.random() * 60 - 30;
            }
            snowflakeGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, transparent: true, opacity: 0.8 });
            snowflakeGroup = new THREE.Points(snowflakeGeo, snowMat);
            scene.add(snowflakeGroup);

            camera.position.z = 18;
            document.getElementById('loading').style.display = 'none';

            // Kích hoạt nhạc khi người dùng tương tác
            music = document.getElementById('christmasMusic');
            document.body.addEventListener('click', () => {
                music.play();
            }, { once: true });
        }

        // CẢM BIẾN TAY
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6 });
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const h = results.multiHandLandmarks[0];
                const dist = Math.sqrt(Math.pow(h[4].x - h[8].x, 2) + Math.pow(h[4].y - h[8].y, 2));
                let s = dist * 11;
                s = Math.max(0.4, Math.min(s, 2.8));
                treeGroup.scale.set(s, s, s);
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });

        function animate() {
            requestAnimationFrame(animate);
            if(treeGroup) treeGroup.rotation.y += 0.012;
            if(star) {
                star.rotation.y += 0.05;
                star.scale.set(1 + Math.sin(Date.now() * 0.005) * 0.1, 1 + Math.sin(Date.now() * 0.005) * 0.1, 1 + Math.sin(Date.now() * 0.005) * 0.1);
            }
            
            const snowArr = snowflakeGroup.geometry.attributes.position.array;
            for (let i = 1; i < snowArr.length; i += 3) {
                snowArr[i] -= 0.06;
                if (snowArr[i] < -20) snowArr[i] = 20;
            }
            snowflakeGroup.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        init3D();
        cam.start();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
